---
title: Convert Org-Table To YAML For Jekyll
tagline: Creating an YAML exporter for Org-Table
blog-category: hacker
category:
- hacker
- exploration
tag:
- hacker
- elisp
- org-mode
- yaml
---

<div id="outline-container-orgc2cebd0" class="outline-2">
<h2 id="orgc2cebd0">Problem</h2>
<div class="outline-text-2" id="text-orgc2cebd0">
<p>
So in making the page for my watch list for the other watcher blog, I
have to convert my unofficial list in Org-Table format to a YAML
format. There are other default formats such as CSV that Jekyll reads
but in keeping with the spirit, I opt to do it as such. The sad thing
about this though is that <b>there is no YAML exporter for
org-table-export</b>, so I made my own. Here is the <a href="https://gist.github.com/3fcc4452ce9714f2d3a6f81ac0cd7ccd">snippet</a> to do and a
demonstration.
</p>

<p>
<img src="/hacker/images/orgtbl-to-yaml--screencast.gif" alt="Screencast"/>
</p>

<p>
And to use it, you point the mark at a table and use
<code>org-table-export</code> and at the format selection you type
<code>fn/orgtbl-to-yaml</code>. With Jekyll, you have to export it to your <code>_data</code>
Jekyll directory to work as stated by the <a href="https://jekyllrb.com/docs/datafiles/">manual</a>. But of course, we
are here to explore further to what it means.
</p>
</div>
</div>

<div id="outline-container-orga369366" class="outline-2">
<h2 id="orga369366">Org-Table Export</h2>
<div class="outline-text-2" id="text-orga369366">
<p>
Initially, I thought I had to create a table parser and transformer
but there is usually a command or function that does what you want
albeit with a little tweaking. The command <code>org-table-export</code> is our
friend here but it is lacking when presented with the format: CSV,
TSV, HTML, LaTeX and others but not YAML. One thing to look at where
this option comes from is <code>org-export-backends</code> but might be overkill
to configure. As an caveat, if you add a backend to it you need to
run this script.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(progn
  (setq org-export-registered-backends
     (cl-remove-if-not
      (lambda (backend)
        (let ((name (org-export-backend-name backend)))
          (or (memq name val)
             (catch 'parentp
               (dolist (b val)
                 (and (org-export-derived-backend-p b name)
                    (throw 'parentp t)))))))
      org-export-registered-backends))
  (let ((new-list (mapcar #'org-export-backend-name
                        org-export-registered-backends)))
    (dolist (backend val)
      (cond
       ((not (load (format "ox-%s" backend) t t))
        (message "Problems while trying to load export back-end `%s'"
                 backend))
       ((not (memq backend new-list)) (push backend new-list))))
    (set-default 'org-export-backends new-list)))
</pre>
</div>

<p>
Something simple would be better for our cause. Is crafting a custom
exporter instead an option? Thankfully, the manual tells us how to
create a simple custom exporter according to this <a href="http://orgmode.org/manual/Translator-functions.html#Translator-functions">link</a>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun orgtbl-to-language (table params)
  "Convert the orgtbl-mode TABLE to language."
  (orgtbl-to-generic
   table
   (org-combine-plists
    '(:tstart "!BTBL!" :tend "!ETBL!" :lstart "!BL!" :lend "!EL!" :sep "\t")
    params)))
</pre>
</div>

<p>
After reading the documentation, we are interested in two properties:
<code>:skip</code> and <code>:lfmt</code>. The later is more important which controls how a
line is formatted. It accepts a function which takes a list of row
values and returns the record line it represents. Using it as
function, the first value are the row headers and the remaining row
values. We mainly want to focus the function on the value so that is
why have <code>:skip</code> to ignore the first header row. Aside from that, we
can craft our row formatter.
</p>

<p>
Since this is YAML, our record line is a bit more complex. Each record
starts with a dash and space, ends with a newline, separated by a
newline and two spaces for alignment. Each value must be in a <code>&lt;key&gt;:
  &lt;value&gt;</code> format and escaped by <code>"</code>. With a sample data, it would look
something like this:
</p>

<div class="org-src-container">
<pre class="src src-org">- id: "1"
  name: "Muffin"
  description: "Khajit Assassin"
- id: "2"
  name: "Marble"
  description: "Barbarian Alchemist"
</pre>
</div>

<p>
To accomplish this, we need to get the row <code>headers</code> which can be also
found with the <code>car</code> of the <code>table</code> parameter. We then use a
functional zip with the headers and each row values, format
accordingly and profit. With a quick <code>zip</code> shiv, it looks like this.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(lambda (values)
  (concat
   "- "
   (string-join
    (mapcar
     (lambda (pair)
       (lexical-let ((header (car pair))
           (value (cdr pair)))
         (format "%s: \"%s\"" header value)))
     (funcall zip headers values))
    "\n  ")))
</pre>
</div>

<p>
That finishes the core formatter.
</p>
</div>
</div>

<div id="outline-container-orgf2f921d" class="outline-2">
<h2 id="orgf2f921d">Front Matter and Jekyll</h2>
<div class="outline-text-2" id="text-orgf2f921d">
<p>
So this exporter is aimed for Jekyll and I know little about YAML
since I rarely use it.
</p>

<p>
I only want to discuss how the key is produced. You can simply take
the key as is but what if it has spaces? I find it odd having spaces
within object keys, so I prefer to hyphenate it and lowercase for my
ease but obviously you can change it to be camelCase if you want.
Using this in Jekyll, it will look like this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(lexical-let ((headers
     (mapcar
      (lambda (header) ;; Shiv camel casing
        (replace-regexp-in-string
         " " "-"
         (downcase header)))
      (car table))))
  ;; Rest of the code
  )
</pre>
</div>

<div class="org-src-container">
<pre class="src src-javascript">{% for watch in site.data.official-watch-list %}
&lt;p&gt;{{ watch.field }}&lt;/p&gt;
{% endfor %}
</pre>
</div>

<p>
As an example on this, my watch list has a <code>Public Rating</code> field and
my question is how will you access it with a dot notation? You are
welcome to inform me how but I wouldn't like how it would feel and I
am comfortable writing <code>watch.public-rating</code> instead. Aside from that
I have nothing much to say about the naming convention and quoting the
value just in case it gets too long.
</p>
</div>
</div>

<div id="outline-container-org0f63960" class="outline-2">
<h2 id="org0f63960">Default Properties</h2>
<div class="outline-text-2" id="text-org0f63960">
<p>
As a final exploration, let's see how to set the default export
options for a table. I thought setting a header property would be good
enough but according to <code>org-set-property</code> I have to put it under a
header which I find weird since the file represents a single solitary
data set but not a big deal. To show that off from my official file:
</p>

<div class="org-src-container">
<pre class="src src-org">* Official Watch List
   :PROPERTIES:
   :TABLE_EXPORT_FILE: official-watch-list.yaml
   :TABLE_EXPORT_FORMAT: fn/orgtbl-to-yaml
   :END:

   Yes, I have an unofficial watch list for myself
</pre>
</div>

<p>
For my use case when updating my watch list, I want to auto export
then publish the table when it is saved just like my
<code>org-jekyll-blogger-auto-publish-on-save</code> from <a href="https://github.com/FrancisMurillo/org-jekyll-blogger.el">org-jekyll-blogger.el</a>.
It takes a few minutes to write that glue code:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun fn/org-jekyll-blogger-export-and-publish ()
  "Export a table and publish the file accordingly."
  (interactive)
  (if (not (org-at-table-p))
      (if (not (called-interactively-p 'interactive))
          (message "No table at point to publish.")
        (error "Point is not at a table"))
    (org-table-export)

    (lexical-let ((export-file (org-entry-get (point) "TABLE_EXPORT_FILE" t)))
      (if (not export-file)
          (message "No TABLE_EXPORT_FILE property")
        (lexical-let ((export-buffer (find-file-noselect export-file)))
          (with-current-buffer export-buffer
            (org-publish-current-file))
          (message "Table published."))))))

(defun fn/org-jekyll-blogger-auto-publish-table-on-save ()
  "Auto export and publish table on save."
  (interactive)
  (add-hook 'after-save-hook #'fn/org-jekyll-blogger-export-and-publish t t))
</pre>
</div>

<p>
Not the best code but it does the job and not that hard to write
although I had to peek at <code>org-table-export</code> to determine the name of
the file. A small point in this code is using <code>called-interactively-p</code>
which merely indicates if the containing function is called as a
command(via <code>M-x</code> or <code>execute-extended-command</code>) or a function(via
Elisp); this allows me to either throw an error message or an info
message depending on the context. For example, using it directly you
should get an error that you need to mark what table you should export
with the point; but if it is called by a hook, you wouldn't want it to
throw an error since there might be other hooks in play so better an
info message.
</p>
</div>
</div>

<div id="outline-container-org280f589" class="outline-2">
<h2 id="org280f589">Conclusion</h2>
<div class="outline-text-2" id="text-org280f589">
<p>
The two things I deliberately ignored are performance and escaping but
I pray I not see more than 10,000 visual experiences before I worry
about it. With this base, you can come up with a <a href="https://duckduckgo.com/l/?kh=-1&amp;uddg=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FJSON">JSON</a> exporter from a
quick read. For me, I can continue to work with my <code>org</code> workflow and
not worry about the export format.
</p>
</div>
</div>
