---
title: A DSL For Git And Projectile Ignore File
tagline: Creating a DSL for ignore DSLs
blog-category: hacker
category:
- hacker
- exploration
tag:
- hacker
- magit
- projectile
- dsl
- elisp
---

<div id="outline-container-org50da781" class="outline-2">
<h2 id="org50da781">Problem</h2>
<div class="outline-text-2" id="text-org50da781">
<p>
After writing some <a href="https://duckduckgo.com/l/?kh=-1&amp;uddg=https%3A%2F%2Fgithub.com%2Fbbatsov%2Fprojectile">projectile</a> glue and <code>.projectile</code> and <code>.gitignore</code>
files, I thought to myself if I could write code to generate those
files. A DSL so to say. The reason is three-fold:
</p>

<ul class="org-ul">
<li>Write a simple ignore file structure as Elisp code</li>
<li>Allow Elisp variables for dynamic and reusable sections</li>
<li>Have a hand in writing a generic DSL</li>
</ul>

<p>
Aside from my hacking sensibilities, the key concerns of doing so may
be put as:
</p>

<ul class="org-ul">
<li>Maintaining two ignore files when it is just really one with a
different syntax</li>
<li>You cannot reuse blocks of repeating sections with different files</li>
</ul>

<p>
The former is syntactic separation while the later is flexibility and
reusability. For my use case with Elisp, I have two projects: my Emacs
configuration and my <a href="https://github.com/FrancisMurillo/org-jekyll-blogger.el">org-jekyll-blogger.el</a> blog project. Using <code>git</code>
and <code>projectile</code>, I have to more or less copy my ignore files and
tweak it a bit. To address this, I created my own DSL <code>magin</code> to
handle <code>.gitignore</code> files; <code>.projectile</code> is similar in intent but
<code>magin</code> was the library I had in mind as proof.
</p>

<p>
As an example, this is my <a href="https://github.com/FrancisMurillo/.emacs.d">.emacs.d</a> <code>.gitignore</code>:
</p>

<div class="org-src-container">
<pre class="src src-text"># Base files
config.el
personal.el

# Base directory
.cache
extra

# Project specific
working-config.org
my-macros.el

# Library
lib/sandbox
lib/packages
!lib/modules
!lib/scripts

# Block for gtags
GPATH
GTAGS
GRTAGS

# Block for emacs
*.elc
.#*
*Org Src*
</pre>
</div>

<p>
It is generated by this DSL:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span>magin-write-to-project
 `<span style="color: #ff1493;">(</span>delimited <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Context keyword that separates contexts by newlines</span>

   <span style="color: #7fff00;">(</span>context <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Represents a semantic group</span>
    <span style="color: #00bfff;">(</span>comment <span style="color: #68f6cb;">"Base files"</span><span style="color: #00bfff;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">A comment keyword</span>
    <span style="color: #00bfff;">(</span>file ,<span style="color: #ffff00;">(</span>format <span style="color: #68f6cb;">"%s.el"</span> <span style="color: #da70d6;">(</span>file-name-base fn/config-file<span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">A file keyword</span>
    <span style="color: #00bfff;">(</span>file ,<span style="color: #ffff00;">(</span>format <span style="color: #68f6cb;">"%s.el"</span> <span style="color: #da70d6;">(</span>file-name-base fn/personal-file<span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Notice I use a Elisp variable</span>

   <span style="color: #7fff00;">(</span>context
    <span style="color: #00bfff;">(</span>comment <span style="color: #68f6cb;">"Base directory"</span><span style="color: #00bfff;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Generates "# Base directory"</span>
    <span style="color: #00bfff;">(</span>dir <span style="color: #68f6cb;">".cache"</span><span style="color: #00bfff;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">A dir keyword</span>
    <span style="color: #00bfff;">(</span>dir <span style="color: #68f6cb;">"extra"</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">An alias to file but it indicates intends for a directory</span>

   <span style="color: #7fff00;">(</span>context <span style="color: #2872b2;">;</span>
    <span style="color: #00bfff;">(</span>comment <span style="color: #68f6cb;">"Project specific"</span><span style="color: #00bfff;">)</span>
    <span style="color: #00bfff;">(</span>file <span style="color: #68f6cb;">"working-config.org"</span><span style="color: #00bfff;">)</span>

    <span style="color: #00bfff;">(</span>file  ,<span style="color: #ffff00;">(</span>format <span style="color: #68f6cb;">"%s.el"</span> <span style="color: #da70d6;">(</span>file-name-base fmk/macro-file<span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span>


   <span style="color: #7fff00;">(</span>context
    <span style="color: #00bfff;">(</span>comment <span style="color: #68f6cb;">"Library"</span><span style="color: #00bfff;">)</span>
    <span style="color: #00bfff;">(</span>path <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Represents a path prefix</span>
     <span style="color: #68f6cb;">"lib"</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Everything underneath is generated with a "lib" prefix</span>
     <span style="color: #ffff00;">(</span>context
      <span style="color: #da70d6;">(</span>dir <span style="color: #68f6cb;">"sandbox"</span><span style="color: #da70d6;">)</span>
      <span style="color: #da70d6;">(</span>dir <span style="color: #68f6cb;">"packages"</span><span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span>
     <span style="color: #ffff00;">(</span>include
      <span style="color: #da70d6;">(</span>dir <span style="color: #68f6cb;">"modules"</span><span style="color: #da70d6;">)</span>
      <span style="color: #da70d6;">(</span>dir <span style="color: #68f6cb;">"scripts"</span><span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span>

   <span style="color: #7fff00;">(</span><span style="color: #96a5d9; font-weight: bold;">block</span> gtags<span style="color: #7fff00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Reusable blocks</span>
   <span style="color: #7fff00;">(</span><span style="color: #96a5d9; font-weight: bold;">block</span> emacs<span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
 user-emacs-directory <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Rewrites =.gitginore= of `</span><span style="color: #afc0fd; font-weight: bold;">user-emacs-directory</span><span style="color: #2872b2;">'</span>
 <span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
I do hope the DSL is easy to digest. Here are the two libraries for
the interested: <a href="https://gist.github.com/e5b667a8640ba1052138ac9ec5d50ed4">magin</a> and <a href="https://gist.github.com/82a3440565a6794327ed74685ba9902f">projin</a>. If you stay around, I'd like to
discuss the following concepts in crafting it:
</p>

<ul class="org-ul">
<li>Backquote</li>
<li>Dispatching</li>
<li>Implicit Environment</li>
</ul>
</div>
</div>

<div id="outline-container-org38c908d" class="outline-2">
<h2 id="org38c908d">Backquoting</h2>
<div class="outline-text-2" id="text-org38c908d">
<p>
The reason why I was confident in making this DSL is due to thanks to
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html">backquoting</a>: it mixes the use of quoting and expressions in a Lispy
way. I point you to understand <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html">quoting</a> before proceeding, but as a
quick brush it is using list of symbols as data.
</p>

<p>
As an example of quoting:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span>+ 1 2 3<span style="color: #ff8c00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">6</span>

'<span style="color: #ff8c00;">(</span>+ 1 2 3<span style="color: #ff8c00;">)</span>         <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">(+ 1 2 3)</span>
<span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">quote</span> <span style="color: #ff1493;">(</span>+ 1 2 3e<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>


<span style="color: #ff8c00;">(</span>subject linking-verb adjective<span style="color: #ff8c00;">)</span>  <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Missing symbols</span>
'<span style="color: #ff8c00;">(</span>subject linking-verb adjective<span style="color: #ff8c00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">As is</span>
</pre>
</div>

<p>
It also allows for lazy evaluation, the problem arises when we want to
integrate Elisp variables into the equation:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">setq</span> left 1
   right 2<span style="color: #ff8c00;">)</span>

<span style="color: #ff8c00;">(</span>+ left right<span style="color: #ff8c00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">3</span>

<span style="color: #ff8c00;">(</span>+ 1 right<span style="color: #ff8c00;">)</span>    <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">3</span>
'<span style="color: #ff8c00;">(</span>+ 1 right<span style="color: #ff8c00;">)</span>   <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">(+ 1 right)</span>

<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Using backquotes</span>
`<span style="color: #ff8c00;">(</span>+ 1 ,right<span style="color: #ff8c00;">)</span>           <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">(+ 1 2)</span>
`<span style="color: #ff8c00;">(</span>+ 1 ,<span style="color: #ff1493;">(</span>+ left right<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>  <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">(+ 1 3)</span>

<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Evaluating the actual value</span>
<span style="color: #ff8c00;">(</span>eval `<span style="color: #ff1493;">(</span>+ 1 ,<span style="color: #7fff00;">(</span>+ left right<span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>  <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">4</span>
</pre>
</div>

<p>
The complicated approach would ask us to create a tokenizer, parser
and compiler while managing text matching and all that jazz; lispy
data structures allows us to bypass this through the quoting. Without
needing anymore, we can create a quoted structures that integrates
with Elisp without any hastle.
</p>
</div>
</div>

<div id="outline-container-orgc8d45d4" class="outline-2">
<h2 id="orgc8d45d4">Domain Syntax</h2>
<div class="outline-text-2" id="text-orgc8d45d4">
<p>
So in thinking of the DSL, let us understand what the domain is. Our
domain of abstraction is <a href="https://git-scm.com/docs/gitignore">gitignore</a>. After some thinking and reading,
this is the abstraction I want to address:
</p>

<ul class="org-ul">
<li>Files and directories have no distinction</li>
<li>Comments</li>
<li>Path context</li>
<li>Separators</li>
<li>Inclusion</li>
<li>Reusable blocks or groups</li>
</ul>

<p>
There are other such abstraction I wish not cover:
</p>

<ul class="org-ul">
<li>Quoting or escaping</li>
<li>Glob keywords, as in <code>rx.el</code>, for single or double asterisk</li>
</ul>

<p>
A DSL that is good enough to accomplish the above is good enough
without being too abstract. Without stretching too much, this DSL has
no intermediate output, it translates directly to text. This tradeoff
loses flexibility in output but at least it is easier. If you wanted,
the DSL can be mechanically a list of plists with a main text
manipulated by several properties as such:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span>magin--compiler
 <span style="color: #ff1493;">(</span>path <span style="color: #68f6cb;">"glob"</span>
       <span style="color: #7fff00;">(</span>include
        <span style="color: #00bfff;">(</span>file <span style="color: #68f6cb;">"foo.bar"</span><span style="color: #00bfff;">)</span>
        <span style="color: #00bfff;">(</span>path <span style="color: #68f6cb;">"gib"</span>
              <span style="color: #ffff00;">(</span>dir <span style="color: #68f6cb;">"foo-bar"</span><span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>

<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">This hypothetically might yield</span>
'<span style="color: #ff8c00;">(</span><span style="color: #ff1493;">(</span><span style="color: #96a5d9; font-style: italic;">:line</span> <span style="color: #68f6cb;">"foo.bar"</span> <span style="color: #96a5d9; font-style: italic;">:include</span> t <span style="color: #96a5d9; font-style: italic;">:parent</span> <span style="color: #68f6cb;">"glob"</span><span style="color: #ff1493;">)</span>
  <span style="color: #ff1493;">(</span><span style="color: #96a5d9; font-style: italic;">:line</span> <span style="color: #68f6cb;">"foo-bar"</span> <span style="color: #96a5d9; font-style: italic;">:include</span> t <span style="color: #96a5d9; font-style: italic;">:parent</span> <span style="color: #68f6cb;">"glob/gib"</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
Without much complexity aside, we can start with hacking with the
simple syntax.
</p>
</div>
</div>

<div id="outline-container-orgc89c476" class="outline-2">
<h2 id="orgc89c476">Keywords</h2>
<div class="outline-text-2" id="text-orgc89c476">
<p>
At last, we define our data structure:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #2872b2;">;; </span><span style="color: #2872b2;">The leaf keywords</span>
<span style="color: #ff8c00;">(</span>file ,line<span style="color: #ff8c00;">)</span>
<span style="color: #ff8c00;">(</span>dir ,line<span style="color: #ff8c00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Alias for file</span>

<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Non functional nodes</span>
<span style="color: #ff8c00;">(</span>comment ,text<span style="color: #ff8c00;">)</span>
<span style="color: #ff8c00;">(</span>newline<span style="color: #ff8c00;">)</span>


<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Syntactic grouping, the equivalent of progn</span>
<span style="color: #ff8c00;">(</span>context <span style="color: #f5b55f;">&amp;rest</span> ,sublines<span style="color: #ff8c00;">)</span>

<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Contextual grouping, like `</span><span style="color: #afc0fd; font-weight: bold;">context</span><span style="color: #2872b2;">' but affects everything inside it</span>
<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Sublines have the property `</span><span style="color: #afc0fd; font-weight: bold;">:include</span><span style="color: #2872b2;">' as `t'</span>
<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Which tells the leaf node to add `!' as a prefix</span>
<span style="color: #ff8c00;">(</span>include <span style="color: #f5b55f;">&amp;rest</span> ,sublines<span style="color: #ff8c00;">)</span>

<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Sublines have the property `</span><span style="color: #afc0fd; font-weight: bold;">:path</span><span style="color: #2872b2;">' set to `</span><span style="color: #afc0fd; font-weight: bold;">path</span><span style="color: #2872b2;">'</span>
<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Nesting of paths are handled</span>
<span style="color: #ff8c00;">(</span>path ,path <span style="color: #f5b55f;">&amp;rest</span> sublines<span style="color: #ff8c00;">)</span>


<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Block keywords</span>
<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Create a variable</span>
<span style="color: #ff8c00;">(</span>defblock ,block-name <span style="color: #f5b55f;">&amp;rest</span> block-lines<span style="color: #ff8c00;">)</span>

<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Call the variable</span>
<span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">block</span> ,block-name<span style="color: #ff8c00;">)</span>


<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Aesthetic grouping</span>
<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Every subline is interleaved with a newline</span>
<span style="color: #ff8c00;">(</span>delimited <span style="color: #f5b55f;">&amp;rest</span> ,sublines<span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
Those are the keywords that we must handle in our DSL. With this in
mind, we can start be creating a function that handles the
compilation.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">defun</span> <span style="color: #bad6e2;">magin--compiler</span> <span style="color: #ff1493;">(</span>dsl <span style="color: #f5b55f;">&amp;optional</span> env<span style="color: #ff1493;">)</span>
  <span style="color: #68f6cb; font-style: italic;">"Compiles DSL with the environment ENV."</span>
  nil<span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
This is our DSL handler, every node that wants to compile nodes have
to go through this dispatching function. This setup allows us to add
more keywords independently of each other. However, we are not going
to use a long <code>switch</code> or <code>cond</code> statement; we will use the implicit
Elisp environment to find handlers. If the compiler comes to a
keyword, it finds a function in the Elisp environment that starts with
<code>magit--dsl-</code> and invokes that as a handler.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">defun</span> <span style="color: #bad6e2;">magin--dsl-context</span> <span style="color: #ff1493;">(</span>dsl env<span style="color: #ff1493;">)</span>
  <span style="color: #68f6cb; font-style: italic;">"File keyword handler."</span><span style="color: #ff8c00;">)</span>

<span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">defun</span> <span style="color: #bad6e2;">magin--dsl-file</span> <span style="color: #ff1493;">(</span>dsl env<span style="color: #ff1493;">)</span>
  <span style="color: #68f6cb; font-style: italic;">"File keyword handler."</span><span style="color: #ff8c00;">)</span>

<span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">defun</span> <span style="color: #bad6e2;">magin--dsl-block</span> <span style="color: #ff1493;">(</span>dsl env<span style="color: #ff1493;">)</span>
  <span style="color: #68f6cb; font-style: italic;">"Block keyword handler."</span><span style="color: #ff8c00;">)</span>

<span style="color: #ff8c00;">(</span>magin--compiler
 `<span style="color: #ff1493;">(</span>context
   <span style="color: #7fff00;">(</span>file <span style="color: #68f6cb;">"a"</span><span style="color: #7fff00;">)</span>
   <span style="color: #7fff00;">(</span><span style="color: #96a5d9; font-weight: bold;">block</span> emacs<span style="color: #7fff00;">)</span>
   <span style="color: #7fff00;">(</span>unknown<span style="color: #7fff00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Error, no `</span><span style="color: #afc0fd; font-weight: bold;">magit--dsl-unknown</span><span style="color: #2872b2;">'</span>
   <span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
In the example above, the compiler finds the three functions above and
calls them but fails on the last one. So if you want to extend it
without messing with the source, one can simply define a function with
the prefix and it will be detected by the compiler. This is similar to
how <code>use-package</code> does it with its keywords. A global dependency
injection if you will. This magic is done through <code>intern-soft</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">lexical-let*</span> <span style="color: #ff1493;">(</span><span style="color: #7fff00;">(</span>rule-name <span style="color: #00bfff;">(</span>symbol-name rule<span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span>
    <span style="color: #7fff00;">(</span>rule-handler
     <span style="color: #00bfff;">(</span>intern-soft
      <span style="color: #ffff00;">(</span>format <span style="color: #68f6cb;">"%s%s"</span> magin-dsl-prefix rule-name<span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
  <span style="color: #ff1493;">(</span><span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #7fff00;">(</span>null rule-handler<span style="color: #7fff00;">)</span>
      <span style="color: #7fff00;">(</span><span style="color: #f5b55f; text-decoration: underline;">error</span> <span style="color: #68f6cb;">"No rule to handle %s at dsl: %s"</span> rule-name dsl<span style="color: #7fff00;">)</span>
    <span style="color: #7fff00;">(</span>funcall rule-handler dsl env<span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
As a side note, you can use an <code>hash-map</code> or create your own <code>obarray</code>
or symbol environemt if you really wanted a private space. In our
approach, you can see the symbols with the helpful <code>describe-variable</code>
without extra work.
</p>

<p>
If you want to use <code>eval-sexp</code> with the raw DSL, you have to create
your own <code>eval</code> and <code>env</code>. You can remap <code>eval</code> with <code>magin-compiler</code>,
but you need to know when it is evaluating a DSL or a Lisp. We're not
creating a new interpreter or environment, so this is good enough.
</p>

<p>
With this simple mechanism, we can define the keywords incrementally.
</p>
</div>
</div>

<div id="outline-container-org87fcf52" class="outline-2">
<h2 id="org87fcf52">Context Keyword</h2>
<div class="outline-text-2" id="text-org87fcf52">
<p>
So our dispatcher is a function that takes a dsl and an environment
which returns a text. Without the intermediate data structure, the
context is applying the dispatcher to each line and then combining it
with a newline delimiter as such:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span>string-join
 <span style="color: #ff1493;">(</span>mapcar  <span style="color: #7fff00;">(</span><span style="color: #96a5d9; font-weight: bold;">lambda</span> <span style="color: #00bfff;">(</span>subdsl<span style="color: #00bfff;">)(</span>funcall #'magin--compiler subdsl env<span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span> subdsls<span style="color: #ff1493;">)</span>
 <span style="color: #68f6cb;">"\n"</span><span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
This is simply lining up the entries. Nothing complicated but how
about manipulating those that manipulate the environment?
</p>
</div>
</div>

<div id="outline-container-orge865983" class="outline-2">
<h2 id="orge865983">Environmental Keyword</h2>
<div class="outline-text-2" id="text-orge865983">
<p>
A quick way to create an environment like scoping, one can easily use
an alist and it will take care of itself. For example with the
<code>include</code> keyword:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">lexical-let</span> <span style="color: #ff1493;">(</span><span style="color: #7fff00;">(</span>new-env <span style="color: #00bfff;">(</span>append <span style="color: #ffff00;">(</span>list <span style="color: #da70d6;">(</span>cons <span style="color: #96a5d9; font-style: italic;">:include</span> t<span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span> env<span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
  <span style="color: #ff1493;">(</span>magin--dsl-context dsl new-env<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
You could use plist but have to implement an <code>extend</code> function for it.
Interestingly, you could also use an alist to simulate an enviroment
and lexical scoping without much problem.
</p>

<p>
It is as simple as appending the <code>cons</code> entry and it is done. The
others are implemented the same way. Now how about implementing the
leaf keywords
</p>
</div>
</div>

<div id="outline-container-orgdfc9967" class="outline-2">
<h2 id="orgdfc9967">Leaf Keyword</h2>
<div class="outline-text-2" id="text-orgdfc9967">
<p>
The implementation above forces everything to the leaf node which
really have only one important one, <code>file</code>. The file has to take the
text value and format it based on the environment.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">lexical-let*</span> <span style="color: #ff1493;">(</span><span style="color: #7fff00;">(</span>parent <span style="color: #00bfff;">(</span>cdr <span style="color: #ffff00;">(</span>assoc <span style="color: #96a5d9; font-style: italic;">:parent</span> env<span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span>
    <span style="color: #7fff00;">(</span>include <span style="color: #00bfff;">(</span><span style="color: #96a5d9; font-weight: bold;">if</span> <span style="color: #ffff00;">(</span>cdr <span style="color: #da70d6;">(</span>assoc <span style="color: #96a5d9; font-style: italic;">:include</span> env<span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span><span style="color: #68f6cb;">"!"</span> nil<span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
  <span style="color: #ff1493;">(</span>concat include parent file<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
Our friend is <code>assoc</code> and <code>cdr</code> when manipulating an alist enviroment.
Again, it is simply a matter formatting. So writing a DSL with this
setup is actually easy.
</p>
</div>
</div>

<div id="outline-container-orgc8a42fb" class="outline-2">
<h2 id="orgc8a42fb">Block Keyword</h2>
<div class="outline-text-2" id="text-orgc8a42fb">
<p>
Lastly, let's talk about defining a block variable. Like with the
dispatcher, we can use the implicit Elisp environment as the variable
space. No need to define a hash of symbols and lookups, we already
have one and we take advantage of it. The keyword <code>defblock</code> will
simply save the defintion into a symbol with a <code>magin--block-</code> prefix
and the other one, <code>block</code>, looks for it. Aside from <code>intern-soft</code>,
the complimentary friend is <code>makunbound</code>, which unbinds the symbol so
the value is updated properly.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">lexical-let*</span> <span style="color: #ff1493;">(</span><span style="color: #7fff00;">(</span>block-name <span style="color: #00bfff;">(</span>symbol-name block-symbol<span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span>
    <span style="color: #7fff00;">(</span>block-def-name <span style="color: #00bfff;">(</span>intern
                     <span style="color: #ffff00;">(</span>format <span style="color: #68f6cb;">"%s%s"</span>
                             magin-block-prefix
                             block-name<span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
  <span style="color: #ff1493;">(</span>makunbound block-def-name<span style="color: #ff1493;">)</span>
  <span style="color: #ff1493;">(</span>eval `<span style="color: #7fff00;">(</span><span style="color: #96a5d9; font-weight: bold;">defvar</span> ,block-def-name '<span style="color: #00bfff;">(</span>context ,@block-def<span style="color: #00bfff;">)</span>
           ,<span style="color: #00bfff;">(</span>format <span style="color: #68f6cb;">"Block definition for %s"</span> block-name<span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
  block-def-name<span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
Aside from using some direct <code>eval</code> magic, it is as straightforward as
it gets as well as with the <code>block</code> handler. With this, we can have
our resusable blocks of code.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span>magin--dsl-defblock
 `<span style="color: #ff1493;">(</span>defblock emacs
    <span style="color: #7fff00;">(</span>comment <span style="color: #68f6cb;">"Block for emacs"</span><span style="color: #7fff00;">)</span>
    <span style="color: #7fff00;">(</span>file <span style="color: #68f6cb;">"*.elc"</span><span style="color: #7fff00;">)</span>
    <span style="color: #7fff00;">(</span>file <span style="color: #68f6cb;">".#*"</span><span style="color: #7fff00;">)</span>
    <span style="color: #7fff00;">(</span>file <span style="color: #68f6cb;">"*Org Src*"</span><span style="color: #7fff00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">Org Src buffers</span>
    <span style="color: #ff1493;">)</span>
 <span style="color: #ff1493;">(</span>list<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org860ae33" class="outline-2">
<h2 id="org860ae33">Non-functional Keyword</h2>
<div class="outline-text-2" id="text-org860ae33">
<p>
The least important is the non-functional ones, like with <code>comment</code>
and <code>newline</code> which are prefixed text and an empty text respectively.
However, the <code>delimited</code> keyword is a bit more complex that it
interleaves each line with a <code>newline</code> keyword.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">lexical-let</span> <span style="color: #ff1493;">(</span><span style="color: #7fff00;">(</span>delimited-dsls
     <span style="color: #00bfff;">(</span>cdr
      <span style="color: #ffff00;">(</span>apply #'append
         <span style="color: #da70d6;">(</span>mapcar
          <span style="color: #00ff7f;">(</span><span style="color: #96a5d9; font-weight: bold;">lambda</span> <span style="color: #ff8247;">(</span>dsl<span style="color: #ff8247;">)</span>
            <span style="color: #ff8247;">(</span>list '<span style="color: #9cb6ad;">(</span>newline<span style="color: #9cb6ad;">)</span> dsl<span style="color: #ff8247;">)</span><span style="color: #00ff7f;">)</span>
          subdsls<span style="color: #da70d6;">)</span><span style="color: #ffff00;">)</span><span style="color: #00bfff;">)</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
  <span style="color: #ff1493;">(</span>magin--compiler
   `<span style="color: #7fff00;">(</span>context
     ,@delimited-dsls<span style="color: #7fff00;">)</span>
   env<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>
</pre>
</div>

<p>
Take your pick in implementing <code>interleave</code> but the thing here is that
it wraps the old context with a newly modified one. It may not be a
big thing but this interferes with debugging and tracing when you
don't know the original source. This is one weakness of this approach
that it interferes with the dsl itself. Nothing terrible but it is the
price of having the return value as text instead of an intermediate
value.
</p>

<p>
With all those ideas, the DSL is easily implemented.
</p>
</div>
</div>

<div id="outline-container-orgfb3dfe6" class="outline-2">
<h2 id="orgfb3dfe6">Wrap Up</h2>
<div class="outline-text-2" id="text-orgfb3dfe6">
<p>
So with this design and implementation we have a crud but simple and
dynamic DSL. You can look at the main defintion and notice the use of
backquoting in how it addresses the problems mentioned. Now I can
manage my ignore file with Emacs.
</p>

<p>
Now for some minor things we might have forgotten:
</p>

<ul class="org-ul">
<li>Unit tests</li>
<li>Logging</li>
<li>Debugging</li>
</ul>

<p>
The DSL is not too complex to warrant any of those but it is nice to
note and implement. As one final point, we could have used a
<code>defmacro</code> instead of a dispatch compiler but in case we want to
update our code in order to join other contexts, we have a base.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">setq</span> left-code `<span style="color: #ff1493;">(</span>context
               <span style="color: #7fff00;">(</span>file <span style="color: #68f6cb;">"a"</span><span style="color: #7fff00;">)</span>
               <span style="color: #7fff00;">(</span>file <span style="color: #68f6cb;">"b"</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span>
   right-code `<span style="color: #ff1493;">(</span>context
                <span style="color: #7fff00;">(</span>file <span style="color: #68f6cb;">"c"</span><span style="color: #7fff00;">)</span>
                <span style="color: #7fff00;">(</span>file <span style="color: #68f6cb;">"d"</span><span style="color: #7fff00;">)</span><span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>


<span style="color: #ff8c00;">(</span>magin-join left-code right-code<span style="color: #ff8c00;">)</span> <span style="color: #2872b2;">;; </span><span style="color: #2872b2;">???</span>
</pre>
</div>

<p>
If we are dealing with text, we can't have this yet. In particular if
you have an initial defintion and want to update it according some
condition, then it requires changing the code to handle plist or
something that fancies the data.
</p>

<p>
To reiterate, Elisp allows us to create a DSL with ease and little
knowledge.
</p>
</div>
</div>

<div id="outline-container-org9fbf889" class="outline-2">
<h2 id="org9fbf889">Conclusion</h2>
<div class="outline-text-2" id="text-org9fbf889">
<p>
So I copied this code to create <code>projin</code> for <code>projectile</code> ignore file
but unless I need more functionality, I don't think I need it for now.
If another ignore file comes my way, I might refactor and do the same.
</p>

<p>
The one thing I want to really write is a DSL for SQL writing, not SQL
itself. My dream is to write SQL as blocks of data.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #ff8c00;">(</span><span style="color: #96a5d9; font-weight: bold;">setq</span> display-fields '<span style="color: #ff1493;">(</span>fields first-name last-name middle-name<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>

<span style="color: #ff8c00;">(</span>select
 display-fields
 <span style="color: #ff1493;">(</span>from table<span style="color: #ff1493;">)</span><span style="color: #ff8c00;">)</span>
<span style="color: #2872b2;">;; </span><span style="color: #2872b2;">"SELECT firstName, lastName, middleName FROM table"</span>
</pre>
</div>

<p>
The idea in that snippet is the fields are data itself. It also
extends to queries being data but the abstraction of aliasing and
joining is sketchy for now. That is my dream though: to write a DSL
for SQL writing. For now, ignore files are good practice.
</p>
</div>
</div>
