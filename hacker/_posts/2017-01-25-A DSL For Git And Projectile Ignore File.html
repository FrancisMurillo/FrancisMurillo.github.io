---
title: A DSL For Git And Projectile Ignore File
tagline: Check out this new post
blog-category: hacker
category:
- hacker
- exploration
tag:
- hacker
- magit
- projectile
- dsl
- elisp
---

<div id="outline-container-org50da781" class="outline-2">
<h2 id="org50da781">Problem</h2>
<div class="outline-text-2" id="text-org50da781">
<p>
After writing some <a href="https://duckduckgo.com/l/?kh=-1&amp;uddg=https%3A%2F%2Fgithub.com%2Fbbatsov%2Fprojectile">projectile</a> glue and <code>.projectile</code> and <code>.gitignore</code>
files, I thought to myself if I could write code to generate those
files. A DSL so to say. The reason is three-fold:
</p>

<ul class="org-ul">
<li>Write a simple ignore file structure as Elisp code</li>
<li>Allow Elisp variables for dynamic and reusable sections</li>
<li>Have a hand in writing a generic DSL</li>
</ul>

<p>
Aside from my hacking sensibilities, the key concerns of doing so may
be put as:
</p>

<ul class="org-ul">
<li>Maintaining two ignore files when it is just really one with a
different syntax</li>
<li>You cannot reuse blocks of repeating sections with different files</li>
</ul>

<p>
The former is syntactic separation while the later is flexibility and
reusability. For my use case with Elisp, I have two projects: my Emacs
configuration and my <a href="https://github.com/FrancisMurillo/org-jekyll-blogger.el">org-jekyll-blogger.el</a> blog project. Using <code>git</code>
and <code>projectile</code>, I have to more or less copy my ignore files and
tweak it a bit. To address this, I created my own DSL <code>magin</code> to
handle <code>.gitignore</code> files; <code>.projectile</code> is similar in intent but
<code>magin</code> was the library I had in mind as proof.
</p>

<p>
As an example, this is my <a href="https://github.com/FrancisMurillo/.emacs.d">.emacs.d</a> <code>.gitignore</code>:
</p>

<div class="org-src-container">
<pre class="src src-text"># Base files
config.el
personal.el

# Base directory
.cache
extra

# Project specific
working-config.org
my-macros.el

# Library
lib/sandbox
lib/packages
!lib/modules
!lib/scripts

# Block for gtags
GPATH
GTAGS
GRTAGS

# Block for emacs
*.elc
.#*
*Org Src*
</pre>
</div>

<p>
It is generated by this DSL:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(magin-write-to-project
 `(delimited ;; Context keyword that separates contexts by newlines

   (context ;; Represents a semantic group
    (comment "Base files") ;; A comment keyword
    (file ,(format "%s.el" (file-name-base fn/config-file))) ;; A file keyword
    (file ,(format "%s.el" (file-name-base fn/personal-file)))) ;; Notice I use a Elisp variable

   (context
    (comment "Base directory") ;; Generates "# Base directory"
    (dir ".cache") ;; A dir keyword
    (dir "extra")) ;; An alias to file but it indicates intends for a directory

   (context ;
    (comment "Project specific")
    (file "working-config.org")

    (file  ,(format "%s.el" (file-name-base fmk/macro-file))))


   (context
    (comment "Library")
    (path ;; Represents a path prefix
     "lib" ;; Everything underneath is generated with a "lib" prefix
     (context
      (dir "sandbox")
      (dir "packages"))
     (include
      (dir "modules")
      (dir "scripts"))))

   (block gtags) ;; Reusable blocks
   (block emacs))
 user-emacs-directory ;; Rewrites =.gitginore= of `user-emacs-directory'
 )
</pre>
</div>

<p>
I do hope the DSL is easy to digest. Here are the two libraries for
the interested: <a href="https://gist.github.com/e5b667a8640ba1052138ac9ec5d50ed4">magin</a> and <a href="https://gist.github.com/82a3440565a6794327ed74685ba9902f">projin</a>. If you stay around, I'd like to
discuss the following concepts in crafting it:
</p>

<ul class="org-ul">
<li>Backquote</li>
<li>Dispatching</li>
<li>Implicit Environment</li>
</ul>
</div>
</div>

<div id="outline-container-org38c908d" class="outline-2">
<h2 id="org38c908d">Backquoting</h2>
<div class="outline-text-2" id="text-org38c908d">
<p>
The reason why I was confident in making this DSL is due to thanks to
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html">backquoting</a>: it mixes the use of quoting and expressions in a Lispy
way. I point you to understand <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html">quoting</a> before proceeding, but as a
quick brush it is using list of symbols as data.
</p>

<p>
As an example of quoting:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(+ 1 2 3) ;; 6

'(+ 1 2 3)         ;; (+ 1 2 3)
(quote (+ 1 2 3e))


(subject linking-verb adjective)  ;; Missing symbols
'(subject linking-verb adjective) ;; As is
</pre>
</div>

<p>
It also allows for lazy evaluation, the problem arises when we want to
integrate Elisp variables into the equation:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(setq left 1
   right 2)

(+ left right) ;; 3

(+ 1 right)    ;; 3
'(+ 1 right)   ;; (+ 1 right)

;; Using backquotes
`(+ 1 ,right)           ;; (+ 1 2)
`(+ 1 ,(+ left right))  ;; (+ 1 3)

;; Evaluating the actual value
(eval `(+ 1 ,(+ left right)))  ;; 4
</pre>
</div>

<p>
The complicated approach would ask us to create a tokenizer, parser
and compiler while managing text matching and all that jazz; lispy
data structures allows us to bypass this through the quoting. Without
needing anymore, we can create a quoted structures that integrates
with Elisp without any hastle.
</p>
</div>
</div>

<div id="outline-container-orgc8d45d4" class="outline-2">
<h2 id="orgc8d45d4">Domain Syntax</h2>
<div class="outline-text-2" id="text-orgc8d45d4">
<p>
So in thinking of the DSL, let us understand what the domain is. Our
domain of abstraction is <a href="https://git-scm.com/docs/gitignore">gitignore</a>. After some thinking and reading,
this is the abstraction I want to address:
</p>

<ul class="org-ul">
<li>Files and directories have no distinction</li>
<li>Comments</li>
<li>Path context</li>
<li>Separators</li>
<li>Inclusion</li>
<li>Reusable blocks or groups</li>
</ul>

<p>
There are other such abstraction I wish not cover:
</p>

<ul class="org-ul">
<li>Quoting or escaping</li>
<li>Glob keywords, as in <code>rx.el</code>, for single or double asterisk</li>
</ul>

<p>
A DSL that is good enough to accomplish the above is good enough
without being too abstract. Without stretching too much, this DSL has
no intermediate output, it translates directly to text. This tradeoff
loses flexibility in output but at least it is easier. If you wanted,
the DSL can be mechanically a list of plists with a main text
manipulated by several properties as such:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(magin--compiler
 (path "glob"
       (include
        (file "foo.bar")
        (path "gib"
              (dir "foo-bar")))))

;; This hypothetically might yield
'((:line "foo.bar" :include t :parent "glob")
  (:line "foo-bar" :include t :parent "glob/gib"))
</pre>
</div>

<p>
Without much complexity aside, we can start with hacking with the
simple syntax.
</p>
</div>
</div>

<div id="outline-container-orgc89c476" class="outline-2">
<h2 id="orgc89c476">Keywords</h2>
<div class="outline-text-2" id="text-orgc89c476">
<p>
At last, we define our data structure:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">;; The leaf keywords
(file ,line)
(dir ,line) ;; Alias for file

;; Non functional nodes
(comment ,text)
(newline)


;; Syntactic grouping, the equivalent of progn
(context &amp;rest ,sublines)

;; Contextual grouping, like `context' but affects everything inside it
;; Sublines have the property `:include' as `t'
;; Which tells the leaf node to add `!' as a prefix
(include &amp;rest ,sublines)

;; Sublines have the property `:path' set to `path'
;; Nesting of paths are handled
(path ,path &amp;rest sublines)


;; Block keywords
;; Create a variable
(defblock ,block-name &amp;rest block-lines)

;; Call the variable
(block ,block-name)


;; Aesthetic grouping
;; Every subline is interleaved with a newline
(delimited &amp;rest ,sublines)
</pre>
</div>

<p>
Those are the keywords that we must handle in our DSL. With this in
mind, we can start be creating a function that handles the
compilation.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun magin--compiler (dsl &amp;optional env)
  "Compiles DSL with the environment ENV."
  nil)
</pre>
</div>

<p>
This is our DSL handler, every node that wants to compile nodes have
to go through this dispatching function. This setup allows us to add
more keywords independently of each other. However, we are not going
to use a long <code>switch</code> or <code>cond</code> statement; we will use the implicit
Elisp environment to find handlers. If the compiler comes to a
keyword, it finds a function in the Elisp environment that starts with
<code>magit--dsl-</code> and invokes that as a handler.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defun magin--dsl-context (dsl env)
  "File keyword handler.")

(defun magin--dsl-file (dsl env)
  "File keyword handler.")

(defun magin--dsl-block (dsl env)
  "Block keyword handler.")

(magin--compiler
 `(context
   (file "a")
   (block emacs)
   (unknown) ;; Error, no `magit--dsl-unknown'
   ))
</pre>
</div>

<p>
In the example above, the compiler finds the three functions above and
calls them but fails on the last one. So if you want to extend it
without messing with the source, one can simply define a function with
the prefix and it will be detected by the compiler. This is similar to
how <code>use-package</code> does it with its keywords. A global dependency
injection if you will. This magic is done through <code>intern-soft</code>:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(lexical-let* ((rule-name (symbol-name rule))
    (rule-handler
     (intern-soft
      (format "%s%s" magin-dsl-prefix rule-name))))
  (if (null rule-handler)
      (error "No rule to handle %s at dsl: %s" rule-name dsl)
    (funcall rule-handler dsl env)))
</pre>
</div>

<p>
As a side note, you can use an <code>hash-map</code> or create your own <code>obarray</code>
or symbol environemt if you really wanted a private space. In our
approach, you can see the symbols with the helpful <code>describe-variable</code>
without extra work.
</p>

<p>
If you want to use <code>eval-sexp</code> with the raw DSL, you have to create
your own <code>eval</code> and <code>env</code>. You can remap <code>eval</code> with <code>magin-compiler</code>,
but you need to know when it is evaluating a DSL or a Lisp. We're not
creating a new interpreter or environment, so this is good enough.
</p>

<p>
With this simple mechanism, we can define the keywords incrementally.
</p>
</div>
</div>

<div id="outline-container-org87fcf52" class="outline-2">
<h2 id="org87fcf52">Context Keyword</h2>
<div class="outline-text-2" id="text-org87fcf52">
<p>
So our dispatcher is a function that takes a dsl and an environment
which returns a text. Without the intermediate data structure, the
context is applying the dispatcher to each line and then combining it
with a newline delimiter as such:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(string-join
 (mapcar  (lambda (subdsl)(funcall #'magin--compiler subdsl env)) subdsls)
 "\n")
</pre>
</div>

<p>
This is simply lining up the entries. Nothing complicated but how
about manipulating those that manipulate the environment?
</p>
</div>
</div>

<div id="outline-container-orge865983" class="outline-2">
<h2 id="orge865983">Environmental Keyword</h2>
<div class="outline-text-2" id="text-orge865983">
<p>
A quick way to create an environment like scoping, one can easily use
an alist and it will take care of itself. For example with the
<code>include</code> keyword:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(lexical-let ((new-env (append (list (cons :include t)) env)))
  (magin--dsl-context dsl new-env))
</pre>
</div>

<p>
You could use plist but have to implement an <code>extend</code> function for it.
Interestingly, you could also use an alist to simulate an enviroment
and lexical scoping without much problem.
</p>

<p>
It is as simple as appending the <code>cons</code> entry and it is done. The
others are implemented the same way. Now how about implementing the
leaf keywords
</p>
</div>
</div>

<div id="outline-container-orgdfc9967" class="outline-2">
<h2 id="orgdfc9967">Leaf Keyword</h2>
<div class="outline-text-2" id="text-orgdfc9967">
<p>
The implementation above forces everything to the leaf node which
really have only one important one, <code>file</code>. The file has to take the
text value and format it based on the environment.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(lexical-let* ((parent (cdr (assoc :parent env)))
    (include (if (cdr (assoc :include env))"!" nil)))
  (concat include parent file))
</pre>
</div>

<p>
Our friend is <code>assoc</code> and <code>cdr</code> when manipulating an alist enviroment.
Again, it is simply a matter formatting. So writing a DSL with this
setup is actually easy.
</p>
</div>
</div>

<div id="outline-container-orgc8a42fb" class="outline-2">
<h2 id="orgc8a42fb">Block Keyword</h2>
<div class="outline-text-2" id="text-orgc8a42fb">
<p>
Lastly, let's talk about defining a block variable. Like with the
dispatcher, we can use the implicit Elisp environment as the variable
space. No need to define a hash of symbols and lookups, we already
have one and we take advantage of it. The keyword <code>defblock</code> will
simply save the defintion into a symbol with a <code>magin--block-</code> prefix
and the other one, <code>block</code>, looks for it. Aside from <code>intern-soft</code>,
the complimentary friend is <code>makunbound</code>, which unbinds the symbol so
the value is updated properly.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(lexical-let* ((block-name (symbol-name block-symbol))
    (block-def-name (intern
                     (format "%s%s"
                             magin-block-prefix
                             block-name))))
  (makunbound block-def-name)
  (eval `(defvar ,block-def-name '(context ,@block-def)
           ,(format "Block definition for %s" block-name)))
  block-def-name)
</pre>
</div>

<p>
Aside from using some direct <code>eval</code> magic, it is as straightforward as
it gets as well as with the <code>block</code> handler. With this, we can have
our resusable blocks of code.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(magin--dsl-defblock
 `(defblock emacs
    (comment "Block for emacs")
    (file "*.elc")
    (file ".#*")
    (file "*Org Src*") ;; Org Src buffers
    )
 (list))
</pre>
</div>
</div>
</div>

<div id="outline-container-org860ae33" class="outline-2">
<h2 id="org860ae33">Non-functional Keyword</h2>
<div class="outline-text-2" id="text-org860ae33">
<p>
The least important is the non-functional ones, like with <code>comment</code>
and <code>newline</code> which are prefixed text and an empty text respectively.
However, the <code>delimited</code> keyword is a bit more complex that it
interleaves each line with a <code>newline</code> keyword.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(lexical-let ((delimited-dsls
     (cdr
      (apply #'append
         (mapcar
          (lambda (dsl)
            (list '(newline) dsl))
          subdsls)))))
  (magin--compiler
   `(context
     ,@delimited-dsls)
   env))
</pre>
</div>

<p>
Take your pick in implementing <code>interleave</code> but the thing here is that
it wraps the old context with a newly modified one. It may not be a
big thing but this interferes with debugging and tracing when you
don't know the original source. This is one weakness of this approach
that it interferes with the dsl itself. Nothing terrible but it is the
price of having the return value as text instead of an intermediate
value.
</p>

<p>
With all those ideas, the DSL is easily implemented.
</p>
</div>
</div>

<div id="outline-container-orgfb3dfe6" class="outline-2">
<h2 id="orgfb3dfe6">Wrap Up</h2>
<div class="outline-text-2" id="text-orgfb3dfe6">
<p>
So with this design and implementation we have a crud but simple and
dynamic DSL. You can look at the main defintion and notice the use of
backquoting in how it addresses the problems mentioned. Now I can
manage my ignore file with Emacs.
</p>

<p>
Now for some minor things we might have forgotten:
</p>

<ul class="org-ul">
<li>Unit tests</li>
<li>Logging</li>
<li>Debugging</li>
</ul>

<p>
The DSL is not too complex to warrant any of those but it is nice to
note and implement. As one final point, we could have used a
<code>defmacro</code> instead of a dispatch compiler but in case we want to
update our code in order to join other contexts, we have a base.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(setq left-code `(context
               (file "a")
               (file "b"))
   right-code `(context
                (file "c")
                (file "d")))


(magin-join left-code right-code) ;; ???
</pre>
</div>

<p>
If we are dealing with text, we can't have this yet. In particular if
you have an initial defintion and want to update it according some
condition, then it requires changing the code to handle plist or
something that fancies the data.
</p>

<p>
To reiterate, Elisp allows us to create a DSL with ease and little
knowledge.
</p>
</div>
</div>

<div id="outline-container-org9fbf889" class="outline-2">
<h2 id="org9fbf889">Conclusion</h2>
<div class="outline-text-2" id="text-org9fbf889">
<p>
So I copied this code to create <code>projin</code> for <code>projectile</code> ignore file
but unless I need more functionality, I don't think I need it for now.
If another ignore file comes my way, I might refactor and do the same.
</p>

<p>
The one thing I want to really write is a DSL for SQL writing, not SQL
itself. My dream is to write SQL as blocks of data.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(setq display-fields '(fields first-name last-name middle-name))

(select
 display-fields
 (from table))
;; "SELECT firstName, lastName, middleName FROM table"
</pre>
</div>

<p>
The idea in that snippet is the fields are data itself. It also
extends to queries being data but the abstraction of aliasing and
joining is sketchy for now. That is my dream though: to write a DSL
for SQL writing. For now, ignore files are good practice.
</p>
</div>
</div>
